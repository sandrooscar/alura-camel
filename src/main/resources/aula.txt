*** DSL-Domain Specific Language
Apache Camel é um framework Java de código aberto que tenta deixar a integração mais simples e acessível para todos os desenvolvedores. Ele faz isso através de:

Implementações concretas dos padrões de integração (EIP)
Conectividade com uma grande variedade de protocolos e APIs
Uso de uma Domain Specific Languages (DSLs) para amarrar os EIPs e protocolos
Segundo os autores do framework, o significado de Camel é: - Concise - Application - Message - Exchange - Language.

*** Geração ID
Para gerar a id, o Camel usa o nome da máquina na rede concatenado com um seed.

Em casos raros, pode ser preciso personalizar a geração dessa id. Isso pode ser feito a partir do CamelContext, passando um gerador propriamente implementado:

context.setUuidGenerator(new MeuGeradorPersonalizado());

*** FLUXO BIDIRECIONAL - Message Exchange Pattens (MEP)
O fluxo pode ser bidirecional sim! Veja o exemplo de uma rota abaixo:

HTTP <-------> log  <-------> HTTPCOPIAR CÓDIGO
Nesse caso, temos uma mensagem de ida (IN) e uma de volta (OUT). Para representar o IN e o OUT, o Exchange Message é na verdade um container. Esse container guarda então as mensagens e outras informações como a id, cabeçalhos e propriedades:



Tudo bem até aqui?

No mundo dos padrões de integração (EIP), o exemplo unidirecional é chamado de Event Message ou InOnly. O exemplo bidirecional é chamado de Request-Reply ou InOut. Event Message e Request-Reply são Message Exchange Pattens (MEP).

Ambos os padrões são representados por meio de um Exchange Pattern, que podemos imprimir na rota:

from("file:pedidos").
  log("${exchange.pattern}"). 
  log("${id} - ${body}").
to("file:saida");COPIAR CÓDIGO
Segue o link do Camel, que possui mais informações sobre MEP: http://camel.apache.org/exchange-pattern.html

Eu sei que tudo isso é um vocabulário bastante diferente, mas vamos devagar. Com o tempo, ficará mais simples usar todos esses padrões e definições. Bem-vindo ao mundo de integração com Apache Camel.

*** ESTILOS DE INTEGRAÇÃO
Você nunca ouviu falar dos estilos de integração? Não tem problema!!

Já falamos que integração é algo difícil e por isso sempre há mais de uma abordagem ou forma de integração de aplicações, cada qual com sua especificidade. Se as necessidades de integração eram sempre as mesmas, só haveria uma forma ou um estilo de integração.

Os 4 estilos de integração identificados são: File Transfer (Troca de arquivos), Messaging (Mensageria), Shared Database (Banco compartilhado) e Remote Procedure Call (Chamada de procedimento remotamente).

No famoso livro chamado Enterprise Integration Patterns, são descritos vários padrões de integração com mais detalhes:

http://www.enterpriseintegrationpatterns.com/patterns/messaging/IntegrationStylesIntro.html

Na nossa primeira rota com Camel, usamos um estilo: o File Sharing. Um exemplo concreto do Messaging é JMS com ActiveMQ, que usaremos mais pra frente. O estilo Shared Database é nada mais que um banco com uma tabela em que duas aplicações acessam/compartilham. Vamos testar isso nos exercícios. Um exemplo concreto do RPC (Remote Procedure Call) é SOAP, que também faz parte do treinamento.

*** SPRING COM CAMEL
Para saber mais: Camel com Spring
PRÓXIMA ATIVIDADE

Nas aulas, utilizamos o Apache Camel de maneira standalone. É comum no mercado, subir a nossa implementação Camel usando o Spring - que inclusive possui boa integração com o Camel. Assim podemos rodar o Spring com Camel dentro de um servlet container como o Tomcat ou Jetty com pouca configuração:

Dentro do arquivo de configuração do Spring devemos declarar o CamelContext:

<context:component-scan base-package="br.com.meupacote"/>

<camelContext xmlns="http://camel.apache.org/schema/spring">
    <contextScan/>
</camelContext>COPIAR CÓDIGO
Agora podemos injetar o CamelContext ou, usando a classe SpringRouteBuilder, definiremos a nova rota dentro de um Spring Bean:

/**
 * Estendendo a classe SpringRouteBuilder não é preciso adicionar a rota programaticamente.
 */
@Component
public class MinhaRota extends SpringRouteBuilder {

    @Override
    public void configure() throws Exception {
        //aqui vem a rota!!
    }

}COPIAR CÓDIGO
Obs: Esse exercício foi submetido pelo aluno Anderson.

*** AULA02 - 
- Marshal e Unmarshal se referem a transformação de um objeto para um outro formato e vice-versa. Por exemplo, usando o padrão JAX-B podemos facilmente transformar um objeto em XML usando marshal/unmarshal
- O interessante é que todos os métodos adicionados nas opções desse exercício também existem. O método xstream() é responsável por gerar um XML, a partir do objeto Java. O método serialization() usa a serialização do Java IO e o método jacksonxml() transforma um JSON em um XML (usando a biblioteca de JSON Jackson).

*** AULA03 - item 3
- Camel envia um POST automaticamente. Esse é o padrão do Camel quando há um corpo (body) da mensagem 
--uso de constant e exchange
Observe que usamos o método constant() no valor do header, responsável por definir o método HTTP. Como o Camel já tinha usado um POST, o resultado será o mesmo se executarmos novamente.

Repare também que usamos outra constante, mas da classe Exchange para definir a chave do cabeçalho. A classe Exchange é fundamental no Camel, não só para o uso de constantes como também para trabalhar com a mensagem em si. Uma mensagem no Camel é do tipo Exchange. Veremos ainda mais sobre esta classe.

**Guardar deados da rota
 método setProperty que serve para guardar dados da rota:

setProperty("pedidoId", xpath("/pedido/id/text()"))COPIAR CÓDIGO
Uma vez guardada uma propriedade, podemos recuperá-la por meio da Expression language usando o método simple():

simple(“${property.pedidoId}”)

** Criterios para definicao de rotas
O Camel precisa decidir e ele segue alguns critérios:

O Camel usa o método HTTP configurado na rota (na rota não configuramos nada, essa regra não se aplica então).
Usa-se o GET se há uma query string configurada (ainda não fizemos isso, também não aplica).
Usa-se o POST se o body não for nulo (o body existe, então, aplica-se POST).
Usa-se GET como último caso.
 
 ** Constnt e simple - diferenças
 o método simple(..) interpreta a Expression Language. Por exemplo usamos o simple(..) para ler uma propriedade:

...
setHeader(Exchange.HTTP_QUERY,  simple("clienteId=${property.clienteId}&pedidoId=${property.pedidoId}&ebookId=${property.ebookId}")).
...COPIAR CÓDIGO
O método constant(..) serve para transformar um valor fixo em uma expressão:

setHeader(Exchange.FILE_NAME, constant("index.html")).COPIAR CÓDIGO
Repare também que o método xpath() também devolve uma Expression:

Expression expr = xpath("/pedido/id/text()")COPIAR CÓDIGO
Seguem os links da documentação dos métodos constant(..) e simple(..):

http://camel.apache.org/constant.html

http://camel.apache.org/simple.html

** O que aprendemos?
trabalhar com o componente http4;
enviar GET e POST;
definir params da requisição GET;
definir e recuperar propriedades na rota.

*** AULA04 - legibilidade 
* Usamos o componente direct com o objetivo de facilitar a manutenção e a legibilidade:

from("file:pedidos?delay=5s").
to("direct:http").
to("direct:soap");

from("direct:http").
//codigo omitido
to("http4://.....");

from("direct:soap").
log("chamando servico soap")
to("mock:soap");

* O multicast() possui uma configuração para chamar cada sub-rota em uma Thread separada. Assim as sub-rotas serão processadas em paralelo:

from("file:pedidos?delay=5s&noop=true").
    multicast().
        parallelProcessing().
            to("direct:soap").
            to("direct:http");COPIAR CÓDIGO
Devemos ter cuidado com essa opção, pois possíveis problemas (exceções) também ocorrem em paralelo que pode complicar a análise do problema.

Podemos definir um timeout no processamento:

from("file:pedidos?delay=5s&noop=true").
    multicast().
        parallelProcessing().
            timeout(500). //millis
                to("direct:soap").
                to("direct:http");
                
* O que aprendemos?
dividir a rota em sub-rotas;
chamar uma sub-rota com direct;
enviar a mesma mensagem pelo multicast;
identificar a rota através da routeId.


